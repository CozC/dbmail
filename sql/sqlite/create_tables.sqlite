-- Copyright (C) 2005 Internet Connection, Inc.
--
-- This program is free software; you can redistribute it and/or 
-- modify it under the terms of the GNU General Public License 
-- as published by the Free Software Foundation; either 
-- version 2 of the License, or (at your option) any later 
-- version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program; if not, write to the Free Software
-- Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-- $Id: create_tables.sqlite 2070 2006-04-18 09:32:55Z paul $

BEGIN TRANSACTION;

CREATE TABLE dbmail_aliases (
   alias_idnr INTEGER PRIMARY KEY,
   alias TEXT NOT NULL,
   deliver_to TEXT NOT NULL,
   client_idnr INTEGER DEFAULT '0' NOT NULL
);
CREATE INDEX dbmail_aliases_index_1 ON dbmail_aliases(alias);
CREATE INDEX dbmail_aliases_index_2 ON dbmail_aliases(client_idnr);

CREATE TABLE dbmail_users (
   user_idnr INTEGER PRIMARY KEY,
   userid TEXT NOT NULL,
   passwd TEXT NOT NULL,
   client_idnr INTEGER DEFAULT '0' NOT NULL,
   maxmail_size INTEGER DEFAULT '0' NOT NULL,
   curmail_size INTEGER DEFAULT '0' NOT NULL,
   encryption_type TEXT DEFAULT '' NOT NULL,
   last_login DATETIME DEFAULT '1979-11-03 22:05:58' NOT NULL
);
CREATE UNIQUE INDEX dbmail_users_1 ON dbmail_users(userid);

CREATE TABLE dbmail_mailboxes (
   mailbox_idnr INTEGER PRIMARY KEY,
   owner_idnr INTEGER DEFAULT '0' NOT NULL,
   name TEXT BINARY NOT NULL,
   seen_flag BOOLEAN default '0' not null,
   answered_flag BOOLEAN default '0' not null,
   deleted_flag BOOLEAN default '0' not null,
   flagged_flag BOOLEAN default '0' not null,
   recent_flag BOOLEAN default '0' not null,
   draft_flag BOOLEAN default '0' not null,
   no_inferiors BOOLEAN default '0' not null,
   no_select BOOLEAN default '0' not null,
   permission BOOLEAN default '2'
);
CREATE INDEX dbmail_mailboxes_1 ON dbmail_mailboxes(name);
CREATE INDEX dbmail_mailboxes_2 ON dbmail_mailboxes(owner_idnr);
CREATE UNIQUE INDEX dbmail_mailboxes_3 ON dbmail_mailboxes(owner_idnr,name);

-- dbmail_mailboxes.owner_idnr references dbmail_users(user_idnr) on delete cascade on update cascade

CREATE TRIGGER fk_insert_mailboxes_users_idnr
	BEFORE INSERT ON dbmail_mailboxes
	FOR EACH ROW BEGIN
		SELECT CASE 
			WHEN (new.owner_idnr IS NOT NULL)
				AND ((SELECT user_idnr FROM dbmail_users WHERE user_idnr = new.owner_idnr) IS NULL)
			THEN RAISE (ABORT, 'insert on table "dbmail_mailboxes" violates foreign key constraint "fk_insert_mailboxes_users_idnr"')
		END;
	END;
CREATE TRIGGER fk_update1_mailboxes_users_idnr
	BEFORE UPDATE ON dbmail_mailboxes
	FOR EACH ROW BEGIN
		SELECT CASE 
			WHEN (new.owner_idnr IS NOT NULL)
				AND ((SELECT user_idnr FROM dbmail_users WHERE user_idnr = new.owner_idnr) IS NULL)
			THEN RAISE (ABORT, 'update on table "dbmail_mailboxes" violates foreign key constraint "fk_update2_mailboxes_users_idnr"')
		END;
	END;
CREATE TRIGGER fk_update2_mailboxes_users_idnr
	AFTER UPDATE ON dbmail_users
	FOR EACH ROW BEGIN
		UPDATE dbmail_mailboxes SET owner_idnr = new.user_idnr WHERE owner_idnr = OLD.user_idnr;
	END;
CREATE TRIGGER fk_delete_mailboxes_users_idnr
	BEFORE DELETE ON dbmail_users
	FOR EACH ROW BEGIN
		DELETE FROM dbmail_mailboxes WHERE owner_idnr = OLD.user_idnr;
	END;


CREATE TABLE dbmail_subscription (
	user_id INTEGER NOT NULL,
	mailbox_id INTEGER NOT NULL
);
CREATE UNIQUE INDEX dbmail_subscriptioin_1 ON dbmail_subscription(user_id, mailbox_id);

-- dbmail_subscription.user_id references dbmail_users(user_idnr) on delete cascade on update cascade

CREATE TRIGGER fk_insert_subscription_users_idnr
	BEFORE INSERT ON dbmail_subscription
	FOR EACH ROW BEGIN
		SELECT CASE 
			WHEN (new.user_id IS NOT NULL)
				AND ((SELECT user_idnr FROM dbmail_users WHERE user_idnr = new.user_id) IS NULL)
			THEN RAISE (ABORT, 'insert on table "dbmail_subscription" violates foreign key constraint "fk_insert_subscription_users_idnr"')
		END;
	END;
CREATE TRIGGER fk_update1_subscription_users_idnr
	BEFORE UPDATE ON dbmail_subscription
	FOR EACH ROW BEGIN
		SELECT CASE 
			WHEN (new.user_id IS NOT NULL)
				AND ((SELECT user_idnr FROM dbmail_users WHERE user_idnr = new.user_id) IS NULL)
			THEN RAISE (ABORT, 'update on table "dbmail_subscription" violates foreign key constraint "fk_update1_subscription_users_idnr"')
		END;
	END;
CREATE TRIGGER fk_update2_subscription_users_idnr
	AFTER UPDATE ON dbmail_users
	FOR EACH ROW BEGIN
		UPDATE dbmail_subscription SET user_id = new.user_idnr WHERE user_id = OLD.user_idnr;
	END;
CREATE TRIGGER fk_delete_subscription_users_idnr
	BEFORE DELETE ON dbmail_users
	FOR EACH ROW BEGIN
		DELETE FROM dbmail_subscription WHERE user_id = OLD.user_idnr;
	END;


-- dbmail_subscription.mailbox_id references dbmail_mailboxes(mailbox_idnr) on delete cascade on update cascade

CREATE TRIGGER fk_insert_subscription_mailbox_id
	BEFORE INSERT ON dbmail_subscription
	FOR EACH ROW BEGIN
		SELECT CASE 
			WHEN (new.mailbox_id IS NOT NULL)
				AND ((SELECT mailbox_idnr FROM dbmail_mailboxes WHERE mailbox_idnr = new.mailbox_id) IS NULL)
			THEN RAISE (ABORT, 'insert on table "dbmail_subscription" violates foreign key constraint "fk_insert_subscription_mailbox_id"')
		END;
	END;
CREATE TRIGGER fk_update1_subscription_mailbox_id
	BEFORE UPDATE ON dbmail_subscription
	FOR EACH ROW BEGIN
		SELECT CASE 
			WHEN (new.mailbox_id IS NOT NULL)
				AND ((SELECT mailbox_idnr FROM dbmail_mailboxes WHERE mailbox_idnr = new.mailbox_id) IS NULL)
			THEN RAISE (ABORT, 'update on table "dbmail_subscription" violates foreign key constraint "fk_update1_subscription_mailbox_id"')
		END;
	END;
CREATE TRIGGER fk_update2_subscription_mailbox_id
	AFTER UPDATE ON dbmail_mailboxes
	FOR EACH ROW BEGIN
		UPDATE dbmail_subscription SET mailbox_id = new.mailbox_idnr WHERE mailbox_idnr = OLD.mailbox_idnr;
	END;
CREATE TRIGGER fk_delete_subscription_mailbox_id
	BEFORE DELETE ON dbmail_mailboxes
	FOR EACH ROW BEGIN
		DELETE FROM dbmail_subscription WHERE mailbox_id = OLD.mailbox_idnr;
	END;


CREATE TABLE dbmail_acl (
	user_id INTEGER NOT NULL,
	mailbox_id INTEGER NOT NULL,
	lookup_flag BOOLEAN default '0' not null,
	read_flag BOOLEAN default '0' not null,
	seen_flag BOOLEAN default '0' not null,
	write_flag BOOLEAN default '0' not null,
	insert_flag BOOLEAN default '0' not null,	
	post_flag BOOLEAN default '0' not null,
	create_flag BOOLEAN default '0' not null,	
	delete_flag BOOLEAN default '0' not null,	
	administer_flag BOOLEAN default '0' not null
);
CREATE INDEX dbmail_acl_1 ON dbmail_acl(user_id);
CREATE INDEX dbmail_acl_2 ON dbmail_acl(mailbox_id);
CREATE UNIQUE INDEX dbmail_acl_3 ON dbmail_acl(user_id, mailbox_id);

-- CONSTRAINT `dbmail_subscription_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `dbmail_users` (`user_idnr`) ON DELETE CASCADE ON UPDATE CASCADE,
-- CONSTRAINT `dbmail_subscription_ibfk_2` FOREIGN KEY (`mailbox_id`) REFERENCES `dbmail_mailboxes` (`mailbox_idnr`) ON DELETE CASCADE ON UPDATE CASCADE
	
CREATE TABLE dbmail_physmessage (
   id INTEGER PRIMARY KEY,
   messagesize INTEGER DEFAULT '0' NOT NULL,
   rfcsize INTEGER DEFAULT '0' NOT NULL,
   internal_date DATETIME default '0' not null
);
 
CREATE TABLE dbmail_messages (
   message_idnr INTEGER PRIMARY KEY,
   mailbox_idnr INTEGER DEFAULT '0' NOT NULL,
   physmessage_id INTEGER DEFAULT '0' NOT NULL,
   seen_flag BOOLEAN default '0' not null,
   answered_flag BOOLEAN default '0' not null,
   deleted_flag BOOLEAN default '0' not null,
   flagged_flag BOOLEAN default '0' not null,
   recent_flag BOOLEAN default '0' not null,
   draft_flag BOOLEAN default '0' not null,
   unique_id TEXT NOT NULL,
   status BOOLEAN unsigned default '0' not null
);
CREATE INDEX dbmail_messages_1 ON dbmail_messages(mailbox_idnr);
CREATE INDEX dbmail_messages_2 ON dbmail_messages(physmessage_id);
CREATE INDEX dbmail_messages_3 ON dbmail_messages(seen_flag);
CREATE INDEX dbmail_messages_4 ON dbmail_messages(unique_id);
CREATE INDEX dbmail_messages_5 ON dbmail_messages(status);
CREATE INDEX dbmail_messages_6 ON dbmail_messages(mailbox_idnr,status);
CREATE INDEX dbmail_messages_7 ON dbmail_messages(mailbox_idnr,status,seen_flag);
CREATE INDEX dbmail_messages_8 ON dbmail_messages(mailbox_idnr,status,recent_flag);

-- CONSTRAINT `dbmail_messages_ibfk_1` FOREIGN KEY (`physmessage_id`) REFERENCES `dbmail_physmessage` (`id`) ON DELETE CASCADE,
-- CONSTRAINT `dbmail_messages_ibfk_2` FOREIGN KEY (`mailbox_idnr`) REFERENCES `dbmail_mailboxes` (`mailbox_idnr`) ON DELETE CASCADE
    
CREATE TABLE dbmail_messageblks (
   messageblk_idnr INTEGER PRIMARY KEY,
   physmessage_id INTEGER DEFAULT '0' NOT NULL,
   messageblk TEXT NOT NULL,
   blocksize INTEGER DEFAULT '0' NOT NULL,
   is_header BOOLEAN DEFAULT '0' NOT NULL
);
CREATE INDEX dbmail_messageblks_1 ON dbmail_messageblks(physmessage_id);
CREATE INDEX dbmail_messageblks_2 ON dbmail_messageblks(physmessage_id, is_header);

--  CONSTRAINT `dbmail_messageblks_ibfk_1` FOREIGN KEY (`physmessage_id`) REFERENCES `dbmail_physmessage` (`id`) ON DELETE CASCADE
  
--CREATE TABLE dbmail_auto_notifications (
--   user_idnr INTEGER PRIMARY KEY,
--   notify_address VARCHAR(100)
--);

CREATE TABLE dbmail_auto_replies (
   user_idnr INTEGER PRIMARY KEY,
   reply_body TEXT,
   start_date DATETIME DEFAULT '1980-01-01 22:05:58' NOT NULL,
   stop_date DATETIME DEFAULT '1980-01-01 22:05:58' NOT NULL,
   min_interval enum('d','w','m') DEFAULT 'w'
);
-- CONSTRAINT `dbmail_auto_replies_ibfk_1` FOREIGN KEY (`user_idnr`) REFERENCES `dbmail_users` (`user_idnr`) ON DELETE CASCADE ON UPDATE CASCADE

CREATE TABLE dbmail_pbsp (
   idnr INTEGER PRIMARY KEY,
   since DATETIME default '0' not null,
   ipnumber TEXT NOT NULL
);
CREATE UNIQUE INDEX dbmail_pbsp_1 ON dbmail_pbsp(ipnumber);
CREATE INDEX dbmail_pbsp_2 ON dbmail_pbsp(since);

CREATE TABLE dbmail_sievescripts (
  owner_idnr INTEGER DEFAULT '0' NOT NULL,
  name TEXT NOT NULL,
  script TEXT,
  active BOOLEAN default '0' not null
);
CREATE INDEX dbmail_sievescripts_1 ON dbmail_sievescripts(name);
CREATE INDEX dbmail_sievescripts_2 ON dbmail_sievescripts(owner_idnr);
CREATE INDEX dbmail_sievescripts_3 ON dbmail_sievescripts(owner_idnr,name);
-- CONSTRAINT `dbmail_sievescripts_ibfk_1` FOREIGN KEY (`owner_idnr`) REFERENCES `dbmail_users` (`user_idnr`) ON DELETE CASCADE ON UPDATE CASCADE


-- create the user for the delivery chain
INSERT INTO dbmail_users (userid, passwd, encryption_type) 
	VALUES ('__@!internal_delivery_user!@__', '', 'md5');
-- insert the 'anyone' user which is used for ACLs.
INSERT INTO dbmail_users (userid, passwd, encryption_type) 
	VALUES ('anyone', '', 'md5');

COMMIT;
