#! /bin/sh --posix
#
# dbmail init script for debian
# 
# written by Paul J Stevens, 2004-2006
# 
#
### BEGIN INIT INFO
# Provides:          dbmail
# Required-Start:    $syslog $network
# Required-Stop:     $syslog $network
# Should-Start:      $local_fs $remote_fs
# Should-Stop:       $local_fs $remote_fs
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Start dbmail services
# Description:       Run network services provided by dbmail such as
#                    imap-server, pop3-server, lmtp-server, timsieve-server
### END INIT INFO


PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin

IMAPD=/usr/sbin/dbmail-imapd
POP3D=/usr/sbin/dbmail-pop3d
LMTPD=/usr/sbin/dbmail-lmtpd
SIEVE=/usr/sbin/dbmail-timsieved

IMAPD_NAME=dbmail-imapd
POP3D_NAME=dbmail-pop3d
LMTPD_NAME=dbmail-lmtpd
SIEVE_NAME=dbmail-timsieved

NAME="dbmail"

PID_DIR="/var/run/$NAME/"

DESC="dbmail servers"

test -x $IMAPD || exit 0
test -x $POP3D || exit 0
test -x $LMTPD || exit 0

set -e

. /lib/lsb/init-functions

[ -e /etc/default/dbmail ] && . /etc/default/dbmail

ssl_wrapper() {
	# this needs more work. Use stunnel at your own risk,
	# or wait for native support for ssl in dbmail-2  :-(
	# note: stunnel4 in inetd mode will scale better.
	cd /etc/ssl/certs || return 0
	[ -e "$PEMFILE" ] || return 0
	[ -x /usr/sbin/stunnel ] || return 0
	# assuming stunnel runs on the same host as dbmail, even though
	# it aint necessarily so.
	STUNNLOPT="-D 7 -p $PEMFILE -S 0 -a /etc/ssl/certs -t 300 -s dbmail -g dbmail -P $PID_DIR"
	log_progress_msg "SSL wrapper"
	 
	case "$1" in 
		start)
		[ "$START_IMAPD" ] && \
			/usr/sbin/stunnel $STUNNLOPT -r localhost:imap -d imaps 
		[ "$START_POP3D" ] && \
			/usr/sbin/stunnel $STUNNLOPT -r localhost:pop3 -d pop3s
		;;
		
		stop)
		if [ "$START_IMAPD" ]; then
			pidfile="$PID_DIR/stunnel.localhost.imap.pid"
			if [ -f "$pidfile" ]; then
				kill `cat $pidfile` >/dev/null 2>&1 || true
			fi
		fi
		if [ "$START_POP3D" ]; then
			pidfile="$PID_DIR/stunnel.localhost.pop3.pid"
			if [ -f "$pidfile" ]; then
				kill `cat $pidfile` >/dev/null 2>&1 || true
			fi
		fi
		;;
	esac	
	return 0
}	

service_start() {
	eval '_daemon=$'$1
	eval '_name=$'$1'_NAME'
	[ -e $_daemon ] || return 0
	
	log_progress_msg "$_name"
	start-stop-daemon --start --exec $_daemon
	
	r=$?
	if [ $r -gt 0 ]; then
		log_failure_msg "failed"
		return $r
	fi
	
	return 0
	
}


service_stop() {
	eval '_daemon=$'$1
	eval '_name=$'$1'_NAME'
	
	log_progress_msg "$_name"
	start-stop-daemon --stop --retry 10 \
		--pidfile ${PID_DIR}/${_name}.pid >/dev/null 2>&1 || true

	pids=`pidof ${_name}`
	if [ -n  "$pids" ]; then
	echo "=[$pids]="
		log_failure_msg "failed"
		return 1
	fi
	
	return 0
	
}
	
service_reload() {
	eval '_daemon=$'$1
	eval '_name=$'$1'_NAME'
	
	log_progress_msg "$_name"
	start-stop-daemon --stop --signal HUP --quiet \
		--pidfile ${PID_DIR}/${_name}.pid --name ${_name}
	
	r=$?
	if [ $r -gt 0 ]; then
		log_failure_msg "failed"
		return $r
	fi
	
	return 0
	
}

case "$1" in
  start)
	log_daemon_msg "Starting $DESC"
	gr=0
	if [ "$START_IMAPD" ]; then service_start "IMAPD" || let gr=$gr+$?; fi
	if [ "$START_POP3D" ]; then service_start "POP3D" || let gr=$gr+$?; fi
	if [ "$START_LMTPD" ]; then service_start "LMTPD" || let gr=$gr+$?; fi
	if [ "$START_SIEVE" ]; then service_start "SIEVE" || let gr=$gr+$?; fi
	if [ "$START_SSL" ]; then ssl_wrapper start || let gr=$gr+$?; fi
 	log_end_msg $gr
	;;
	
  stop)
	log_daemon_msg "Stopping $DESC"
	gr=0
	if [ "$START_SSL" ]; then ssl_wrapper stop || let gr=$gr+$?; fi
	if [ "$START_IMAPD" ]; then service_stop "IMAPD" || let gr=$gr+$?; fi
	if [ "$START_POP3D" ]; then service_stop "POP3D" || let gr=$gr+$?; fi
	if [ "$START_LMTPD" ]; then service_stop "LMTPD" || let gr=$gr+$?; fi
	if [ "$START_SIEVE" ]; then service_stop "SIEVE" || let gr=$gr+$?; fi
	log_end_msg $gr
	;;
	
  reload)
  	log_daemon_msg "Reloading $DESC"
	if [ "$START_IMAPD" ]; then service_reload "IMAPD" || let r=$r+$?; fi
	if [ "$START_POP3D" ]; then service_reload "POP3D" || let r=$r+$?; fi
	if [ "$START_LMTPD" ]; then service_reload "LMTPD" || let r=$r+$?; fi
	if [ "$START_SIEVE" ]; then service_reload "SIEVE" || let r=$r+$?; fi
	log_end_msg $r
	;;
	
  restart|force-reload)
	$0 stop || true
	$0 start
	;;
  *)
	N="$NAME"
	echo "Usage: $N {start|stop|restart|reload|force-reload}" >&2
	exit 1
	;;
esac

exit 0

